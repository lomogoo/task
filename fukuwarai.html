<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãƒªã‚¢ãƒ«ãƒ»ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ç¦ç¬‘ã„ V4</title>
    <script src="https://pixijs.download/v7.3.2/pixi.min.js"></script>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            text-align: center;
            background-color: #222;
            color: #eee;
            margin: 0;
            padding: 10px;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
        }

        #ui-header {
            flex: 0 0 auto;
            margin-bottom: 10px;
        }

        #control-panel {
            display: none;
            margin-bottom: 8px;
            padding: 5px;
            background: #444;
            border-radius: 5px;
        }

        #canvas-container-flex {
            flex: 1 1 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            overflow: hidden;
        }

        #canvas-wrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border: 1px solid #555;
            background-color: #000;
        }

        #pixi-canvas {
            display: block;
        }

        #draw-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            touch-action: none;
        }

        /* ãƒœã‚¿ãƒ³ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
        button {
            padding: 8px 16px;
            margin: 4px;
            font-size: 14px;
            cursor: pointer;
            background-color: #555;
            color: white;
            border: 1px solid #777;
            border-radius: 4px;
            transition: background 0.2s;
        }

        button:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background-color: #007bff;
            border-color: #007bff;
        }

        .btn-danger {
            background-color: #d9534f;
            border-color: #d9534f;
        }

        .btn-success {
            background-color: #28a745;
            border-color: #28a745;
        }

        /* é¸æŠä¸­ã®ãƒœã‚¿ãƒ³ã‚’å…‰ã‚‰ã›ã‚‹ */
        .mode-active {
            box-shadow: 0 0 8px white;
            border: 2px solid white;
            font-weight: bold;
        }

        #instructions {
            font-size: 0.9rem;
            color: #ccc;
            margin-top: 5px;
            min-height: 1.2em;
        }
    </style>
</head>

<body>

    <h1>ãƒªã‚¢ãƒ«ãƒ»ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ç¦ç¬‘ã„ V4</h1>

    <div id="ui-header">
        <input type="file" id="fileInput" accept="image/*">
        <button id="resetBtn" onclick="location.reload()" style="display:none;">æœ€åˆã‹ã‚‰</button>

        <div id="control-panel">
            <div style="margin-bottom:5px;">
                <span style="font-size:0.8rem; color:#aaa;">STEP 1: </span>
                <button id="btn-outline" onclick="setMode('outline')" class="btn-primary">ğŸ”µ è¼ªéƒ­ã‚«ãƒƒãƒˆ</button>
            </div>
            <div>
                <span style="font-size:0.8rem; color:#aaa;">STEP 2: </span>
                <button id="btn-eye" onclick="setMode('eye')" class="btn-success" disabled>ğŸ‘ï¸ ç›®ã‚’è¿½åŠ </button>
                <button id="btn-mouth" onclick="setMode('mouth')" class="btn-danger" disabled>ğŸ‘„ å£ã‚’è¿½åŠ </button>
            </div>
        </div>
        <div id="instructions">ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„</div>
    </div>

    <div id="canvas-container-flex">
        <div id="canvas-wrapper"></div>
    </div>

    <script>
        // ==========================================
        //  å¤‰æ•°å®šç¾©
        // ==========================================
        let app, baseTexture, imgSprite, faceMaskGraphics;
        const drawCanvas = document.createElement('canvas');
        drawCanvas.id = 'draw-canvas';
        const drawCtx = drawCanvas.getContext('2d');

        let isDrawing = false;
        let points = [];

        // ãƒ¢ãƒ¼ãƒ‰: 'outline' | 'eye' | 'mouth'
        let currentMode = 'outline';

        const animatedMeshes = [];
        let globalTime = 0;

        const wrapper = document.getElementById('canvas-wrapper');
        const fileInput = document.getElementById('fileInput');
        const instructions = document.getElementById('instructions');
        const controlPanel = document.getElementById('control-panel');

        // ãƒœã‚¿ãƒ³å‚ç…§
        const btnOutline = document.getElementById('btn-outline');
        const btnEye = document.getElementById('btn-eye');
        const btnMouth = document.getElementById('btn-mouth');

        // ==========================================
        //  åˆæœŸåŒ–å‡¦ç†
        // ==========================================
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            fileInput.style.display = 'none';
            document.getElementById('resetBtn').style.display = 'inline-block';
            controlPanel.style.display = 'block';

            const reader = new FileReader();
            reader.onload = (event) => initPixi(event.target.result);
            reader.readAsDataURL(file);
        });

        function initPixi(imageUrl) {
            const img = new Image();
            img.onload = () => {
                // ç”»é¢ãƒ•ã‚£ãƒƒãƒˆè¨ˆç®—
                const headerHeight = document.getElementById('ui-header').offsetHeight;
                const availableW = window.innerWidth - 20;
                const availableH = window.innerHeight - headerHeight - 30;
                const scale = Math.min(availableW / img.width, availableH / img.height);
                const w = Math.floor(img.width * scale);
                const h = Math.floor(img.height * scale);

                app = new PIXI.Application({
                    width: w, height: h, backgroundColor: 0x000000, antialias: true
                });
                app.view.id = 'pixi-canvas';
                wrapper.appendChild(app.view);

                drawCanvas.width = w; drawCanvas.height = h;
                wrapper.appendChild(drawCanvas);
                setupDrawingEvents();

                PIXI.Assets.load(imageUrl).then((texture) => {
                    baseTexture = texture;
                    imgSprite = new PIXI.Sprite(texture);
                    imgSprite.width = w; imgSprite.height = h;
                    app.stage.addChild(imgSprite);

                    faceMaskGraphics = new PIXI.Graphics();
                    app.stage.addChild(faceMaskGraphics);

                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
                    app.ticker.add((delta) => {
                        globalTime += delta / 60;
                        updateRealAnimation(globalTime);
                    });

                    setMode('outline'); // æœ€åˆã¯è¼ªéƒ­ãƒ¢ãƒ¼ãƒ‰
                });
            };
            img.src = imageUrl;
        }

        // ==========================================
        //  ãƒ¢ãƒ¼ãƒ‰ç®¡ç†
        // ==========================================
        function setMode(mode) {
            currentMode = mode;

            // ãƒœã‚¿ãƒ³ã®è¦‹ãŸç›®ãƒªã‚»ãƒƒãƒˆ
            [btnOutline, btnEye, btnMouth].forEach(b => b.classList.remove('mode-active'));

            if (mode === 'outline') {
                btnOutline.classList.add('mode-active');
                instructions.textContent = "é¡”ã®è¼ªéƒ­ã‚’ãã‚‹ã£ã¨å›²ã‚“ã§åˆ‡ã‚ŠæŠœã„ã¦ãã ã•ã„";
                drawCtx.strokeStyle = '#007bff'; // é’
            } else if (mode === 'eye') {
                btnEye.classList.add('mode-active');
                instructions.textContent = "ç›®ã‚’å›²ã‚“ã§ãã ã•ã„ï¼ˆãƒªã‚¢ãƒ«ãªç¬ããŒã¤ãã¾ã™ï¼‰";
                drawCtx.strokeStyle = '#28a745'; // ç·‘
            } else if (mode === 'mouth') {
                btnMouth.classList.add('mode-active');
                instructions.textContent = "å£ã‚’å›²ã‚“ã§ãã ã•ã„ï¼ˆèˆŒã¨å£å†…ãŒç”Ÿæˆã•ã‚Œã¾ã™ï¼‰";
                drawCtx.strokeStyle = '#d9534f'; // èµ¤
            }
        }

        function enablePartButtons() {
            btnEye.disabled = false;
            btnMouth.disabled = false;
            btnOutline.disabled = true; // è¼ªéƒ­ã¯1å›ã ã‘
            btnOutline.style.opacity = 0.5;
        }

        // ==========================================
        //  æç”»ï¼ˆãªãã‚Šï¼‰ã‚¤ãƒ™ãƒ³ãƒˆ
        // ==========================================
        function setupDrawingEvents() {
            const start = (e) => {
                isDrawing = true; points = [];
                points.push(getPos(e));
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                drawCtx.beginPath();
                drawCtx.moveTo(points[0].x, points[0].y);
            };
            const move = (e) => {
                if (!isDrawing) return;
                const p = getPos(e);
                points.push(p);
                drawCtx.lineTo(p.x, p.y);
                drawCtx.lineWidth = 3;
                drawCtx.stroke();
            };
            const end = (e) => {
                if (!isDrawing) return;
                isDrawing = false;
                drawCtx.closePath(); drawCtx.stroke();
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

                if (points.length < 10) return; // çŸ­ã™ãã‚‹ç·šã¯ç„¡è¦–

                if (currentMode === 'outline') {
                    createOutlineMask(points);
                    enablePartButtons();
                    setMode('eye'); // è‡ªå‹•çš„ã«ç›®ãƒ¢ãƒ¼ãƒ‰ã¸
                } else {
                    // ç›®ã‹å£ã‚’ä½œã‚‹
                    createRealMeshFromSelection(points, currentMode);
                }
            };

            drawCanvas.addEventListener('mousedown', start);
            drawCanvas.addEventListener('mousemove', move);
            drawCanvas.addEventListener('mouseup', end);
            drawCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); start(e.touches[0]); });
            drawCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e.touches[0]); });
            drawCanvas.addEventListener('touchend', (e) => { e.preventDefault(); end(); });
        }

        function getPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        // ==========================================
        //  å®Ÿå‡¦ç†ï¼ˆãƒã‚¹ã‚¯ãƒ»ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆï¼‰
        // ==========================================
        function createOutlineMask(pointList) {
            faceMaskGraphics.clear();
            faceMaskGraphics.beginFill(0xFFFFFF);
            if (pointList.length > 0) {
                faceMaskGraphics.moveTo(pointList[0].x, pointList[0].y);
                for (let i = 1; i < pointList.length; i++) {
                    faceMaskGraphics.lineTo(pointList[i].x, pointList[i].y);
                }
            }
            faceMaskGraphics.closePath();
            faceMaskGraphics.endFill();
            imgSprite.mask = faceMaskGraphics;
        }

        function createRealMeshFromSelection(pointList, type) {
            // å›²ã¾ã‚ŒãŸç¯„å›²ã®çŸ©å½¢(ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹)ã‚’è¨ˆç®—
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            pointList.forEach(p => {
                if (p.x < minX) minX = p.x; if (p.y < minY) minY = p.y;
                if (p.x > maxX) maxX = p.x; if (p.y > maxY) maxY = p.y;
            });

            // å°‘ã—ãƒãƒ¼ã‚¸ãƒ³ã‚’ã¨ã‚‹
            const margin = 15;
            minX = Math.max(0, minX - margin); minY = Math.max(0, minY - margin);
            maxX = Math.min(app.screen.width, maxX + margin); maxY = Math.min(app.screen.height, maxY + margin);
            const width = maxX - minX; const height = maxY - minY;

            // Pixiç”¨ã®è¨­å®š
            const segX = 12; const segY = 12;
            const scaleX = baseTexture.width / app.screen.width;
            const scaleY = baseTexture.height / app.screen.height;

            // å…ƒç”»åƒã‹ã‚‰ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—
            const frame = new PIXI.Rectangle(minX * scaleX, minY * scaleY, width * scaleX, height * scaleY);
            const cropTexture = new PIXI.Texture(baseTexture.baseTexture, frame);

            // ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆ
            const plane = new PIXI.SimplePlane(cropTexture, segX, segY);
            plane.x = minX; plane.y = minY; plane.width = width; plane.height = height;

            // ã‚¦ã‚§ã‚¤ãƒˆè¨ˆç®—
            const weights = [];
            const buffer = plane.geometry.getBuffer('aVertexPosition');
            for (let i = 0; i < buffer.data.length; i += 2) {
                const nx = (buffer.data[i] / width);
                const ny = (buffer.data[i + 1] / height);
                const wx = Math.sin(nx * Math.PI);
                const wy = Math.sin(ny * Math.PI);
                weights.push(Math.pow(wx * wy, 2));
            }

            const animData = {
                mesh: plane, baseBuffer: Float32Array.from(buffer.data),
                weights: weights, type: type,
                timeOffset: Math.random() * 10
            };
            animatedMeshes.push(animData);

            // --- å£ãªã‚‰èˆŒã‚’è¿½åŠ ï¼ˆV3ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç§»æ¤ï¼‰ ---
            if (type === 'mouth') {
                const mouthContainer = new PIXI.Container();
                mouthContainer.x = plane.x; mouthContainer.y = plane.y;

                // å£å†…ï¼ˆæš—é—‡ï¼‰
                const innerMouth = new PIXI.Graphics();
                innerMouth.beginFill(0x330000);
                innerMouth.drawEllipse(plane.width / 2, plane.height / 2 + plane.height * 0.1, plane.width * 0.4, plane.height * 0.3);
                innerMouth.endFill();
                mouthContainer.addChild(innerMouth);

                // èˆŒ
                const tongue = new PIXI.Graphics();
                tongue.beginFill(0xE9967A);
                tongue.drawEllipse(plane.width / 2, plane.height / 2 + plane.height * 0.3, plane.width * 0.25, plane.height * 0.2);
                tongue.endFill();
                animData.tongueSprite = tongue;
                mouthContainer.addChild(tongue);

                // ãƒ¡ãƒƒã‚·ãƒ¥ã‚’æ‰‹å‰ã«
                plane.x = 0; plane.y = 0;
                mouthContainer.addChild(plane);

                // ãƒã‚¹ã‚¯è¨­å®š
                innerMouth.mask = plane;
                tongue.mask = plane;
                app.stage.addChild(mouthContainer);

            } else {
                app.stage.addChild(plane);
            }
        }

        // ==========================================
        //  ãƒªã‚¢ãƒ«ãƒ»ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–° (V3ã®ãƒ­ã‚¸ãƒƒã‚¯)
        // ==========================================
        function updateRealAnimation(t) {
            animatedMeshes.forEach(item => {
                const { mesh, baseBuffer, weights, type, timeOffset, tongueSprite } = item;
                const buffer = mesh.geometry.getBuffer('aVertexPosition');
                const localT = t + timeOffset;

                let eyeShut = 0; let mouthOpen = 0;

                if (type === 'eye') {
                    const period = 4.0;
                    const cycle = localT % period;
                    if (cycle < 0.1) eyeShut = cycle / 0.1;
                    else if (cycle < 0.25) eyeShut = 1.0 - (cycle - 0.1) / 0.15;
                    eyeShut = Math.pow(eyeShut, 0.5);
                } else if (type === 'mouth') {
                    mouthOpen = (Math.sin(localT * 8) * 0.5 + Math.sin(localT * 3) * 0.3 + 0.2);
                    mouthOpen = Math.max(0, mouthOpen);

                    if (tongueSprite) {
                        tongueSprite.y = mesh.height * 0.1 - mouthOpen * mesh.height * 0.1;
                        tongueSprite.scale.x = 1 + Math.sin(localT * 20) * 0.05 * mouthOpen;
                    }
                }

                for (let i = 0; i < buffer.data.length; i += 2) {
                    const ox = baseBuffer[i]; const oy = baseBuffer[i + 1];
                    const nx = ox / mesh.width; const ny = oy / mesh.height;
                    const weight = weights[i / 2];
                    let dx = 0; let dy = 0;

                    if (type === 'eye') {
                        if (ny < 0.5) dy = (0.6 - ny) * mesh.height * 0.8 * eyeShut;
                        else dy = -(ny - 0.5) * mesh.height * 0.1 * eyeShut;
                    } else if (type === 'mouth') {
                        if (ny > 0.3) {
                            const jawDrop = (ny - 0.3);
                            dy = jawDrop * mesh.height * 0.5 * mouthOpen;
                            dx = -(nx - 0.5) * mesh.width * 0.3 * mouthOpen;
                        }
                    }

                    const appliedWeight = Math.pow(weight, 0.7);
                    buffer.data[i] = ox + dx * appliedWeight;
                    buffer.data[i + 1] = oy + dy * appliedWeight;
                }
                buffer.update();
            });
        }
    </script>
</body>

</html>